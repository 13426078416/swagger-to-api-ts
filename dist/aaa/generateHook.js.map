{"version":3,"sources":["../../src/aaa/generateHook.js"],"names":["allowedPageParametersNames","generateHook","apis","types","config","code","hasInfinity","useInfiniteQuery","length","sort","serviceName","_serviceName","apisCode","reduce","prev","summary","deprecated","queryParamsTypeName","pathParams","requestBody","headerParams","isQueryParamsNullable","isHeaderParamsNullable","responses","method","queryParameters","hookName","hasPaging","find","name","toLowerCase","isGet","useQuery","getParamsString","override","map","TData","TQueryFnData","TError","getQueryParamName","nullable","isPartial","undefined","TVariables","required","schema","description","join","deps","result","DEPRECATED_WARM_MESSAGE","params","includes","filter","param","startsWith","_name","error","console"],"mappings":"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","file":"generateHook.js","sourcesContent":["import {\n  getTsType,\n  isAscending,\n  getDefineParam,\n  getParamString,\n  toPascalCase,\n  getSchemaName,\n  isMatchWholeWord,\n} from \"./utils\";\nimport {\n  DEPRECATED_WARM_MESSAGE,\n  getHooksFunctions,\n  getHooksImports,\n} from \"./strings\";\nimport { getJsdoc } from \"./utilities/jsdoc\";\n\nconst allowedPageParametersNames = [\"page\", \"pageno\", \"pagenumber\"];\n\nfunction generateHook(apis, types, config) {\n  let code = getHooksImports({\n    hasInfinity: !!config.useInfiniteQuery.length,\n  });\n  try {\n    apis = apis.sort(({ serviceName }, { serviceName: _serviceName }) =>\n      isAscending(serviceName, _serviceName)\n    );\n\n    const apisCode = apis.reduce(\n      (\n        prev,\n        {\n          summary,\n          deprecated,\n          serviceName,\n          queryParamsTypeName,\n          pathParams,\n          requestBody,\n          headerParams,\n          isQueryParamsNullable,\n          isHeaderParamsNullable,\n          responses,\n          method,\n          queryParameters,\n        }\n      ) => {\n        const hookName = `use${toPascalCase(serviceName)}`;\n\n        const hasPaging = config.useInfiniteQuery.find(\n          (name) =>\n            name.toLowerCase() === serviceName.toLowerCase() ||\n            name.toLowerCase() === hookName.toLowerCase()\n        );\n\n        const isGet =\n          hasPaging ||\n          method === \"get\" ||\n          config.useQuery.find(\n            (name) =>\n              name.toLowerCase() === serviceName.toLowerCase() ||\n              name.toLowerCase() === hookName.toLowerCase()\n          );\n        const getParamsString = (override) => ` ${\n          pathParams.length ? `${pathParams.map(({ name }) => name)},` : \"\"\n        }\n          ${requestBody ? \"requestBody,\" : \"\"}\n          ${\n            queryParamsTypeName\n              ? hasPaging && override\n                ? `{\n                  ..._param,\n                  ...queryParams,\n                },`\n                : \"queryParams,\"\n              : \"\"\n          }\n          ${headerParams ? \"headerParams,\" : \"\"}`;\n\n        const TData = `${responses ? getTsType(responses) : \"any\"}`;\n        const TQueryFnData = `ResponseData<${TData}>`;\n        const TError = \"RequestError | Error\";\n\n        const getQueryParamName = (\n          name,\n          nullable = isQueryParamsNullable,\n          isPartial\n        ) =>\n          queryParamsTypeName\n            ? `${getParamString(\n                name,\n                !nullable,\n                queryParamsTypeName,\n                undefined,\n                isPartial\n              )},`\n            : \"\";\n\n        const TVariables = `${\n          /** Path parameters */\n          pathParams\n            .map(({ name, required, schema, description }) =>\n              getDefineParam(name, required, schema, description)\n            )\n            .join(\",\")\n        }${pathParams.length > 0 ? \",\" : \"\"}${\n          /** Request Body */\n          requestBody\n            ? `${getDefineParam(\"requestBody\", true, requestBody)},`\n            : \"\"\n        }${\n          /** Query parameters */\n          getQueryParamName(\"queryParams\")\n        }${\n          /** Header parameters */\n          headerParams\n            ? `${getParamString(\n                \"headerParams\",\n                !isHeaderParamsNullable,\n                headerParams\n              )},`\n            : \"\"\n        }`;\n\n        const deps = `[${serviceName}.key,${\n          pathParams.length ? `${pathParams.map(({ name }) => name)},` : \"\"\n        }\n            ${requestBody ? \"requestBody,\" : \"\"}\n            ${queryParamsTypeName ? \"queryParams,\" : \"\"}\n            ${headerParams ? \"headerParams,\" : \"\"}]`;\n\n        let result =\n          prev +\n          `\n      ${getJsdoc({\n        description: summary,\n        deprecated: deprecated ? DEPRECATED_WARM_MESSAGE : undefined,\n      })}`;\n\n        result += `export const ${hookName} =`;\n        if (!isGet) {\n          result += `<TExtra>`;\n        }\n\n        const params = [\n          `${isGet ? TVariables : \"\"}`,\n          `options?:${\n            hasPaging\n              ? `UseInfiniteQueryOptions<${TQueryFnData}, ${TError}>`\n              : isGet\n              ? `InternalUseQueryOptions<${TData}>`\n              : `${\n                  TVariables\n                    ? `InternalUseMutationOptions<${TData}, {${TVariables}}, TExtra>`\n                    : `InternalUseMutationOptionsVoid<${TData}, TExtra>`\n                }`\n          },`,\n          `${isGet ? `configOverride?:AxiosRequestConfig` : \"\"}`,\n        ];\n\n        result += ` (\n           ${params.join(\"\")}\n           ) => {`;\n        if (isGet) {\n          result += `\n          const { key, fun } = ${hookName}.info(${getParamsString()} configOverride);\n          `;\n          if (hasPaging) {\n            result += `const {\n            data: { pages } = {},\n            data,\n            ...rest\n          } = useInfiniteQuery(\n            key,\n            ({ pageParam = 1 }) =>\n              fun({\n                  ${\n                    queryParameters.find(({ name }) =>\n                      allowedPageParametersNames.includes(name.toLowerCase())\n                    ).name\n                  }:pageParam,\n              }),\n            {\n              getNextPageParam: (_lastPage, allPages) => allPages.length + 1,\n              ...(options as any),\n            },\n          );\n        \n          const list = useMemo(() => paginationFlattenData(pages), [pages]);\n          const total = getTotal(pages);\n\n          const hasMore = useHasMore(pages, list, queryParams);\n          \n          return {...rest, data, list, hasMore, total}\n          `;\n          } else {\n            result += `return useQuery(key,()=>\n                fun(),\n                options\n               )`;\n          }\n        } else {\n          result += `return useMutation((_o)=>{\n            const {${getParamsString()} configOverride } = _o || {};\n\n            return ${serviceName}(\n                ${getParamsString()} configOverride,\n              )\n          },\n          options\n         )`;\n        }\n\n        result += `  \n          }\n        `;\n\n        if (isGet) {\n          result += `${hookName}.info = (${params\n            .filter((param) => !param.startsWith(\"options?:\"))\n            .join(\"\")}) => {\n              return {\n                key: ${deps} as QueryKey,\n                fun: (${\n                  hasPaging ? getQueryParamName(\"_param\", true, true) : \"\"\n                }) =>\n                ${serviceName}(\n                  ${getParamsString(true)}\n                  configOverride\n                ),\n              };\n            };`;\n\n          result += `${hookName}.prefetch = (\n            client: QueryClient,\n            ${params.join(\"\")}) => {\n                const { key, fun } = ${hookName}.info(${getParamsString()} configOverride);\n\n                return client.getQueryData(key)\n                ? Promise.resolve()\n                : client.prefetchQuery(\n                    key,\n                    ()=>fun(),\n                    options\n                  );\n              }`;\n        }\n\n        return result;\n      },\n      \"\"\n    );\n\n    code +=\n      types\n        .sort(({ name }, { name: _name }) => isAscending(name, _name))\n        .reduce((prev, { name: _name }) => {\n          const name = getSchemaName(_name);\n          if (!isMatchWholeWord(apisCode, name)) {\n            return prev;\n          }\n          return prev + ` ${name},`;\n        }, \"import {\") + '}  from \"./types\"\\n';\n    code += getHooksFunctions({\n      hasInfinity: !!config.useInfiniteQuery.length,\n    });\n\n    code +=\n      apis.reduce((prev, { serviceName }) => {\n        return prev + ` ${serviceName},`;\n      }, \"import {\") + '}  from \"./services\"\\n';\n\n    code += `\n    type InternalMutationDefaultParams<TExtra> = {_extraVariables?:TExtra, configOverride?:ResponseData}\n    type InternalUseQueryOptions<TData> = UseQueryOptions<ResponseData<TData>,RequestError | Error>;\n\n    type InternalUseMutationOptions<TData, TRequest, TExtra> = UseMutationOptions<\n    ResponseData<TData>,\n      RequestError | Error,\n      TRequest & InternalMutationDefaultParams<TExtra>\n    >;\n\n    type InternalUseMutationOptionsVoid<\n      TData,\n      TExtra\n    > = UseMutationOptions<\n    ResponseData<TData>,\n      RequestError | Error,\n      InternalMutationDefaultParams<TExtra> | void\n    >;  \n    `;\n\n    code += apisCode;\n\n    return code;\n  } catch (error) {\n    console.error(error);\n    return \"\";\n  }\n}\n\nexport { generateHook };\n"]}