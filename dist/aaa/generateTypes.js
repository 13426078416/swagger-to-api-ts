"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.generateTypes = undefined;

var _extends2 = require("babel-runtime/helpers/extends");

var _extends3 = _interopRequireDefault(_extends2);

var _utils = require("./utils");

var _strings = require("./strings");

var _jsdoc = require("./utilities/jsdoc");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function generateTypes(types, config) {
  var code = _strings.AUTOGENERATED_COMMENT;
  try {
    code += types.sort(function (_ref, _ref2) {
      var name = _ref.name;
      var _name = _ref2.name;
      return (0, _utils.isAscending)(name, _name);
    }).reduce(function (prev, _ref3) {
      var _name = _ref3.name,
          schema = _ref3.schema,
          description = _ref3.description;

      var name = (0, _utils.getSchemaName)(_name);
      prev += "\n        " + (0, _jsdoc.getJsdoc)((0, _extends3.default)({}, schema, {
        description: description || schema.description,
        deprecated: schema.deprecated ? schema["x-deprecatedMessage"] || String(schema.deprecated) : undefined
      })) + "\n        " + getTypeDefinition(name, schema, config) + "\n        ";

      return prev;
    }, "");

    return code;
  } catch (error) {
    console.error({ error: error });
    return "";
  }
}

function getTypeDefinition(name, schema, _ref4) {
  var generateEnumAsType = _ref4.generateEnumAsType;
  var type = schema.type,
      Enum = schema.enum,
      enumNames = schema["x-enumNames"],
      allOf = schema.allOf,
      oneOf = schema.oneOf,
      items = schema.items,
      $ref = schema.$ref,
      additionalProperties = schema.additionalProperties,
      properties = schema.properties;


  if (Enum) {
    if (generateEnumAsType) {
      return "export type " + name + " =" + Enum.map(function (e) {
        return "\"" + e + "\"";
      }).join(" | ") + ";";
    }
    return "export enum " + name + " {" + Enum.map(function (e, index) {
      return (enumNames ? enumNames[index] : e) + "=" + (typeof e === "string" ? "\"" + e + "\"" : "" + e);
    }) + "}";
  }

  if (allOf || oneOf) {
    return "export type " + name + " = " + (0, _utils.getTsType)(schema);
  }

  if (type === "array" && items) {
    return "export type " + name + " = " + (0, _utils.getTsType)(items) + "[]";
  }

  if ($ref) {
    return "export type " + name + " = " + (0, _utils.getRefName)($ref);
  }

  if (type === "object") {
    var typeObject = (0, _utils.getTsType)(schema);

    if ((additionalProperties || properties) && !oneOf) {
      return "export interface " + name + " " + typeObject;
    }

    return "export type " + name + " = " + typeObject;
  }

  if (type === "string") {
    return "export type " + name + " = " + type;
  }

  return "export type " + name + " = any";
}

exports.generateTypes = generateTypes;
//# sourceMappingURL=generateTypes.js.map